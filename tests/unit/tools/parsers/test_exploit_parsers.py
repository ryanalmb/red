"""Comprehensive unit tests for exploitation parsers - 100% coverage."""
import pytest
import uuid
from cyberred.tools.parsers import (
    crackmapexec, responder, secretsdump, psexec, metasploit, searchsploit
)


@pytest.fixture
def agent_id():
    return str(uuid.uuid4())


# ============================================================================
# CRACKMAPEXEC PARSER TESTS
# ============================================================================

@pytest.mark.unit
class TestCrackmapexecParser:
    def test_parser_signature(self, agent_id):
        assert callable(crackmapexec.crackmapexec_parser)
        result = crackmapexec.crackmapexec_parser(stdout='', stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        assert isinstance(result, list)

    def test_empty_stdout(self, agent_id):
        result = crackmapexec.crackmapexec_parser('', '', 0, agent_id, "192.168.1.1")
        assert result == []

    def test_credential_extraction_pwned(self, agent_id):
        stdout = '''SMB 192.168.1.1 445 DC [+] CORP\\admin:Password123 (Pwn3d!)'''
        findings = crackmapexec.crackmapexec_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        assert len(findings) >= 1
        assert any(f.type == "credential" for f in findings)
        assert any(f.severity == "critical" for f in findings)

    def test_credential_without_pwned(self, agent_id):
        stdout = '''SMB 192.168.1.1 445 DC [+] CORP\\user:Password123'''
        findings = crackmapexec.crackmapexec_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        assert len(findings) >= 1

    def test_share_enumeration(self, agent_id):
        stdout = '''SMB 192.168.1.1 445 DC [*] Enumerated shares
SMB 192.168.1.1 445 DC Share           Permissions
SMB 192.168.1.1 445 DC ADMIN$          READ,WRITE
SMB 192.168.1.1 445 DC C$              READ'''
        findings = crackmapexec.crackmapexec_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        share_findings = [f for f in findings if f.type == "share"]
        assert len(share_findings) >= 1

    def test_winrm_authentication(self, agent_id):
        stdout = '''WINRM 192.168.1.10 5985 DC01 [+] CORP\\admin:Password123'''
        findings = crackmapexec.crackmapexec_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.10")
        assert len(findings) >= 1

    def test_ldap_authentication(self, agent_id):
        stdout = '''LDAP 192.168.1.10 389 DC01 [+] CORP\\svc_ldap:LdapPass123'''
        findings = crackmapexec.crackmapexec_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.10")
        assert len(findings) >= 1

    def test_failed_authentication_not_extracted(self, agent_id):
        stdout = '''SMB 192.168.1.1 445 DC [-] CORP\\admin:WrongPassword (STATUS_LOGON_FAILURE)'''
        findings = crackmapexec.crackmapexec_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        # Failed auth should not create credential finding
        cred_findings = [f for f in findings if f.type == "credential" and "WrongPassword" in f.evidence]
        assert len(cred_findings) == 0


# ============================================================================
# RESPONDER PARSER TESTS
# ============================================================================

@pytest.mark.unit
class TestResponderParser:
    def test_parser_signature(self, agent_id):
        assert callable(responder.responder_parser)
        result = responder.responder_parser(stdout='', stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        assert isinstance(result, list)

    def test_empty_stdout(self, agent_id):
        result = responder.responder_parser('', '', 0, agent_id, "192.168.1.1")
        assert result == []

    def test_ntlmv2_hash_extraction_smb(self, agent_id):
        stdout = '''[SMB] NTLMv2-SSP Client   : 192.168.1.50
[SMB] NTLMv2-SSP Username : CORP\\admin
[SMB] NTLMv2-SSP Hash     : admin::CORP:1122334455667788:AABBCCDD11223344:01010000'''
        findings = responder.responder_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        assert len(findings) >= 1
        assert any(f.type == "credential" for f in findings)

    def test_ntlmv2_hash_extraction_http(self, agent_id):
        stdout = '''[HTTP] NTLMv2 Client   : 192.168.1.51
[HTTP] NTLMv2 Username : CORP\\webuser
[HTTP] NTLMv2 Hash     : webuser::CORP:aabbccdd:11223344:01010000'''
        findings = responder.responder_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        assert len(findings) >= 1

    def test_ntlmv2_hash_extraction_ldap(self, agent_id):
        stdout = '''[LDAP] NTLMv2 Client   : 192.168.1.52
[LDAP] NTLMv2 Username : CORP\\ldapuser
[LDAP] NTLMv2 Hash     : ldapuser::CORP:deadbeef:12345678:01010000'''
        findings = responder.responder_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        assert len(findings) >= 1

    def test_multiple_hashes(self, agent_id):
        stdout = '''[SMB] NTLMv2 Hash : user1::CORP:1111:AAAA:0101
[SMB] NTLMv2 Hash : user2::CORP:2222:BBBB:0101
[HTTP] NTLMv2 Hash : user3::CORP:3333:CCCC:0101'''
        findings = responder.responder_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        assert len(findings) >= 3

    def test_high_severity_for_hashes(self, agent_id):
        stdout = '''[SMB] NTLMv2 Hash : admin::CORP:1234:ABCD:0101'''
        findings = responder.responder_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        assert all(f.severity in ["high", "critical"] for f in findings if f.type == "credential")


# ============================================================================
# SECRETSDUMP PARSER TESTS  
# ============================================================================

@pytest.mark.unit
class TestSecretsdumpParser:
    def test_parser_signature(self, agent_id):
        assert callable(secretsdump.secretsdump_parser)
        result = secretsdump.secretsdump_parser(stdout='', stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        assert isinstance(result, list)

    def test_empty_stdout(self, agent_id):
        result = secretsdump.secretsdump_parser('', '', 0, agent_id, "192.168.1.1")
        assert result == []

    def test_sam_hash_extraction(self, agent_id):
        stdout = '''[*] Dumping local SAM hashes (uid:rid:lmhash:nthash)
Administrator:500:aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c:::'''
        findings = secretsdump.secretsdump_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        assert len(findings) >= 1
        assert any("Administrator" in f.evidence for f in findings)

    def test_skips_empty_hashes(self, agent_id):
        stdout = '''Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::'''
        findings = secretsdump.secretsdump_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        # Empty hash accounts should be filtered or have lower priority
        # The parser should still work without errors
        assert isinstance(findings, list)

    def test_cached_domain_credentials(self, agent_id):
        stdout = '''[*] Dumping cached domain logon information (domain/username:hash)
CORP.LOCAL/jsmith:$DCC2$10240#jsmith#aabbccdd11223344'''
        findings = secretsdump.secretsdump_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        # Parser may or may not extract this specific format
        assert isinstance(findings, list)

    def test_lsa_secrets(self, agent_id):
        stdout = '''[*] Dumping LSA Secrets
[*] $MACHINE.ACC
CORP\\DC01$:aes256-cts-hmac-sha1-96:aabbccdd'''
        findings = secretsdump.secretsdump_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        assert len(findings) >= 1

    def test_kerberos_keys(self, agent_id):
        stdout = '''CORP\\DC01$:aes256-cts-hmac-sha1-96:aabbccdd11223344
CORP\\DC01$:aes128-cts-hmac-sha1-96:11223344aabbccdd'''
        findings = secretsdump.secretsdump_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        assert len(findings) >= 1

    def test_critical_severity_for_hashes(self, agent_id):
        stdout = '''Administrator:500:aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c:::'''
        findings = secretsdump.secretsdump_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        cred_findings = [f for f in findings if f.type == "credential"]
        assert all(f.severity == "critical" for f in cred_findings)


# ============================================================================
# PSEXEC PARSER TESTS
# ============================================================================

@pytest.mark.unit
class TestPsexecParser:
    def test_parser_signature(self, agent_id):
        assert callable(psexec.psexec_parser)
        result = psexec.psexec_parser(stdout='', stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        assert isinstance(result, list)

    def test_empty_stdout(self, agent_id):
        result = psexec.psexec_parser('', '', 0, agent_id, "192.168.1.1")
        assert result == []

    def test_shell_access_cmd_prompt(self, agent_id):
        stdout = '''[*] Process cmd.exe created
C:\\Windows\\system32>'''
        findings = psexec.psexec_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        assert len(findings) == 1
        assert findings[0].type == "shell_access"
        assert findings[0].severity == "critical"

    def test_shell_access_whoami(self, agent_id):
        stdout = '''[*] Requesting shares on 192.168.1.10.....
[*] Found writable share ADMIN$
[*] Uploading file
[*] Opening SVCManager
[*] Creating service
[*] Starting service
Microsoft Windows [Version 10.0.17763.1]
C:\\Windows\\system32>whoami
nt authority\\system'''
        findings = psexec.psexec_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.10")
        assert len(findings) >= 1
        assert any(f.type == "shell_access" for f in findings)

    def test_access_denied_no_shell(self, agent_id):
        stdout = '''[*] Requesting shares on 192.168.1.10.....
[-] SMB SessionError: STATUS_ACCESS_DENIED({Access Denied})'''
        findings = psexec.psexec_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.10")
        shell_findings = [f for f in findings if f.type == "shell_access"]
        assert len(shell_findings) == 0

    def test_shell_access_powershell(self, agent_id):
        stdout = '''[*] Process powershell.exe created
PS C:\\Windows\\system32>'''
        findings = psexec.psexec_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        assert len(findings) >= 1


# ============================================================================
# METASPLOIT PARSER TESTS
# ============================================================================

@pytest.mark.unit
class TestMetasploitParser:
    def test_parser_signature(self, agent_id):
        assert callable(metasploit.metasploit_parser)
        result = metasploit.metasploit_parser(stdout='', stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        assert isinstance(result, list)

    def test_empty_stdout(self, agent_id):
        result = metasploit.metasploit_parser('', '', 0, agent_id, "192.168.1.1")
        assert result == []

    def test_meterpreter_session(self, agent_id):
        stdout = '''[*] Meterpreter session 1 opened (192.168.1.1:4444 -> 192.168.1.2:49152)'''
        findings = metasploit.metasploit_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        assert len(findings) == 1
        assert findings[0].type == "session"
        assert findings[0].severity == "critical"
        assert "Meterpreter" in findings[0].evidence

    def test_command_shell_session(self, agent_id):
        stdout = '''[*] Command shell session 2 opened (192.168.1.1:4445 -> 192.168.1.3:49153)'''
        findings = metasploit.metasploit_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        assert len(findings) == 1
        assert findings[0].type == "session"
        assert "Command shell" in findings[0].evidence

    def test_exploit_success(self, agent_id):
        stdout = '''[+] 192.168.1.10:445 - exploit/windows/smb/ms17_010_eternalblue - WIN'''
        findings = metasploit.metasploit_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.10")
        assert len(findings) >= 1
        assert any(f.type == "vuln" for f in findings)

    def test_vulnerable_host(self, agent_id):
        stdout = '''[+] 192.168.1.11:445 - Host is VULNERABLE to MS17-010'''
        findings = metasploit.metasploit_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.11")
        assert len(findings) >= 1
        vuln_findings = [f for f in findings if f.type == "vuln"]
        assert len(vuln_findings) >= 1

    def test_multiple_sessions(self, agent_id):
        stdout = '''[*] Meterpreter session 1 opened (192.168.1.1:4444 -> 192.168.1.2:49152)
[*] Command shell session 2 opened (192.168.1.1:4445 -> 192.168.1.3:49153)'''
        findings = metasploit.metasploit_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="192.168.1.1")
        session_findings = [f for f in findings if f.type == "session"]
        assert len(session_findings) >= 2


# ============================================================================
# SEARCHSPLOIT PARSER TESTS (basic - full tests in test_searchsploit.py)
# ============================================================================

@pytest.mark.unit
class TestSearchsploitParserBasic:
    def test_parser_signature(self, agent_id):
        assert callable(searchsploit.searchsploit_parser)
        result = searchsploit.searchsploit_parser(stdout='', stderr='', exit_code=0, agent_id=agent_id, target="apache")
        assert isinstance(result, list)

    def test_json_parsing(self, agent_id):
        stdout = '{"RESULTS_EXPLOIT": [{"EDB-ID": "12345", "Title": "Apache RCE", "Platform": "linux", "Path": "exploits/linux/12345.py"}]}'
        findings = searchsploit.searchsploit_parser(stdout=stdout, stderr='', exit_code=0, agent_id=agent_id, target="apache")
        assert len(findings) == 1
        assert findings[0].type == "exploit_ref"
