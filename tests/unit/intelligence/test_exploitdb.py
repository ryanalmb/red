import pytest
import json
from dataclasses import is_dataclass

# Note: We import from the package assuming implementation will exist
from cyberred.intelligence.sources.exploitdb import ExploitEntry

@pytest.mark.unit
class TestExploitEntry:
    def test_exploit_entry_structure(self):
        """Test that ExploitEntry has the required fields."""
        assert is_dataclass(ExploitEntry)
        
        # Instantiate with dummy data to verify fields
        entry = ExploitEntry(
            edb_id="12345",
            title="Test Exploit",
            path="/path/to/exploit.py",
            platform="linux",
            exploit_type="remote",
            author="test_author",
            date="2023-01-01",
            cve_ids=["CVE-2023-1234"]
        )
        
        assert entry.edb_id == "12345"
        assert entry.title == "Test Exploit"
        assert entry.path == "/path/to/exploit.py"
        assert entry.platform == "linux"
        assert entry.exploit_type == "remote"
        assert entry.author == "test_author"
        assert entry.date == "2023-01-01"
        assert entry.cve_ids == ["CVE-2023-1234"]

    def test_from_searchsploit(self):
        """Test parsing of searchsploit JSON output to ExploitEntry."""
        # Sample JSON from searchsploit output we verified in Phase 0
        searchsploit_data = {
            "Title": "vsftpd 2.3.4 - Backdoor Command Execution (Metasploit)",
            "EDB-ID": "17491",
            "Date_Published": "2011-07-05",
            "Author": "Metasploit",
            "Type": "remote",
            "Platform": "unix",
            "Path": "/opt/exploitdb/exploits/unix/remote/17491.rb",
            "Codes": "OSVDB-73573;CVE-2011-2523"
        }
        
        entry = ExploitEntry.from_searchsploit(searchsploit_data)
        
        assert entry.edb_id == "17491"
        assert entry.title == "vsftpd 2.3.4 - Backdoor Command Execution (Metasploit)"
        assert entry.path == "/opt/exploitdb/exploits/unix/remote/17491.rb"
        assert entry.platform == "unix"
        assert entry.exploit_type == "remote"
        assert entry.author == "Metasploit"
        assert entry.date == "2011-07-05"
        assert "CVE-2011-2523" in entry.cve_ids

from cyberred.intelligence.base import IntelligenceSource, IntelPriority
from cyberred.intelligence.sources.exploitdb import ExploitDbSource
from unittest.mock import patch, MagicMock
import asyncio
import json

@pytest.mark.unit
class TestExploitDbSource:
    def test_inheritance(self):
        """Test that ExploitDbSource extends IntelligenceSource."""
        assert issubclass(ExploitDbSource, IntelligenceSource)

    def test_initialization(self):
        """Test initialization and default property values."""
        source = ExploitDbSource()
        assert source.name == "exploitdb"
        assert source.priority == IntelPriority.EXPLOITDB
        assert source._searchsploit_path == "searchsploit"
        assert source._base_path == "/usr/share/exploitdb"
        
        # Test custom initialization
        source_custom = ExploitDbSource(
            searchsploit_path="/custom/searchsploit",
            timeout=10.0,
            base_path="/custom/db"
        )
        assert source_custom._searchsploit_path == "/custom/searchsploit"
        assert source_custom._timeout == 10.0
        assert source_custom._base_path == "/custom/db"

    @pytest.mark.asyncio
    async def test_query_success(self):
        """Test query calls searchsploit and returns results."""
        source = ExploitDbSource()
        
        # Mock parsing to return a dummy result
        # We need to mock _parse_results to verify the flow, 
        # or mock just the subprocess call and let it fail on parsing empty output if strictly TDD.
        # But we haven't implemented _parse_results properly yet.
        # Let's mock subprocess.run inside the executor.
        
        from unittest.mock import MagicMock, patch
        import asyncio
        import subprocess

        # Expected output from searchsploit
        mock_output = json.dumps({
            "RESULTS_EXPLOIT": [
                {
                    "Title": "vsftpd 2.3.4 - Backdoor Command Execution",
                    "EDB-ID": "17491",
                    "Type": "remote", 
                    "Platform": "unix",
                    "Path": "/path/to/17491.rb"
                }
            ]
        })

        mock_process = MagicMock()
        mock_process.returncode = 0
        mock_process.stdout = mock_output
        mock_process.stderr = ""

        with patch("asyncio.base_events.BaseEventLoop.run_in_executor") as mock_run:
            mock_run.return_value = asyncio.Future()
            mock_run.return_value.set_result(mock_process)
            
            # Mock _parse_results to avoid testing parsing logic here (it's tested separately)
            # or we can rely on real implementation if we want an integration-style unit test
            # But query calls private _parse_results.
            # Let's see... query() calls self._parse_results(result.stdout)
            # If we don't mock it, it will use the placeholder which returns empty list for now.
            # So the test might fail on assertion of result content.
            # But standard TDD says "Write failing test", so failing on empty list is good.
            
            # However, I also want to verify it CALLS searchsploit correctly.
            
            results = await source.query("vsftpd", "2.3.4")
            
            # Verify executor call
            assert mock_run.called
            args, _ = mock_run.call_args
            # args[0] is None (default executor)
            # args[1] is the callable (lambda)
            # We can't easily inspect lambda, but we know it's called.
            
            # Since we can't inspect the lambda easily without more complex mocking,
            # we rely on the implementation correctness for now or refactor to make it testable.
            # A common pattern is to put the subprocess call in a protected method _run_searchsploit.
            # But the story didn't strictly ask for that.
            
            # Let's check inputs validation/sanitization in query()
            # "safe_service" logic.
            
            pass

    @pytest.mark.asyncio
    async def test_query_calls_subprocess(self):
        """Test that query builds correct command."""
        source = ExploitDbSource()
        
        with patch("subprocess.run") as mock_subprocess:
            mock_subprocess.return_value.returncode = 0
            mock_subprocess.return_value.stdout = "{}"
            
            # We need to mock run_in_executor to actually execute the lambda passed to it,
            # or just mock loop.run_in_executor to return the result of our mock_subprocess.
            # But simpler: just mock subprocess.run and let the real executor run it?
            # Creating a real executor in tests might be slow or problematic.
            # Standard way: patch run_in_executor to execute the function immediately.
            
            with patch("asyncio.base_events.BaseEventLoop.run_in_executor") as mock_executor:
                # Configure mock executor to execute the function passed to it
                def side_effect(executor, func, *args):
                    import asyncio
                    f = asyncio.Future()
                    try:
                        res = func(*args)
                        f.set_result(res)
                    except Exception as e:
                        f.set_exception(e)
                    return f
                
                mock_executor.side_effect = side_effect
                
                await source.query("vsftpd", "2.3.4")
                
                # Now check subprocess.run arguments
                mock_subprocess.assert_called()
                call_args = mock_subprocess.call_args
                cmd = call_args[0][0] # first arg is the command list
                
                assert cmd[0] == "searchsploit"
                assert cmd[1] == "--json"
                assert "vsftpd" in cmd[2]
                assert "2.3.4" in cmd[2]
                assert cmd[2] == "vsftpd 2.3.4"
    
    @pytest.mark.asyncio
    async def test_query_sanitization(self):
        """Test input sanitization."""
        source = ExploitDbSource()
        with patch("subprocess.run") as mock_subprocess:
            mock_subprocess.return_value.returncode = 0
            mock_subprocess.return_value.stdout = "{}"
            
            with patch("asyncio.base_events.BaseEventLoop.run_in_executor") as mock_executor:
                 # Standard mock setup
                mock_executor.return_value = asyncio.Future()
                mock_process = MagicMock()
                mock_process.returncode = 0
                mock_process.stdout = "{}"
                mock_executor.return_value.set_result(mock_process)
                
                # Mock helper to execute the lambda if we want to verify arguments passed to subprocess
                # But here we just want to verify what happened.
                # Actually, capturing the lambda and inspecting it is hard.
                
                # Let's rely on the previous test strategy: execute the lambda via side_effect in mock_executor
                def side_effect(executor, func, *args):
                    f = asyncio.Future()
                    f.set_result(func(*args))
                    return f
                mock_executor.side_effect = side_effect
                
                await source.query("v$ftpd;", "2.3.4&")
                
                mock_subprocess.assert_called()
                cmd = mock_subprocess.call_args[0][0]
                # v$ftpd; -> vftpd
                # 2.3.4& -> 2.3.4
                assert cmd[2] == "vftpd 2.3.4"

    @pytest.mark.asyncio
    async def test_query_error_handling(self):
        """Test error handling returns empty list."""
        source = ExploitDbSource()
        
        with patch("asyncio.base_events.BaseEventLoop.run_in_executor") as mock_executor:
            # Simulate exception
            mock_executor.side_effect = FileNotFoundError("searchsploit not found")
            
            results = await source.query("test", "1.0")
            assert results == []
            
            # Simulate non-zero return code
            mock_executor.side_effect = None
            mock_process = MagicMock()
            mock_process.returncode = 1
            mock_process.stderr = "Error"
            mock_future = asyncio.Future()
            mock_future.set_result(mock_process)
            mock_executor.return_value = mock_future
            
            results = await source.query("test", "1.0")
            assert results == []

    def test_parse_results_valid(self):
        """Test parsing valid searchsploit JSON."""
        source = ExploitDbSource()
        json_output = json.dumps({
            "RESULTS_EXPLOIT": [
                {
                    "Title": "vsftpd 2.3.4 - Backdoor Command Execution",
                    "EDB-ID": "17491",
                    "Type": "remote", 
                    "Platform": "unix",
                    "Path": "/path/to/17491.rb"
                }
            ]
        })
        
        results = source._parse_results(json_output)
        assert len(results) == 1
        assert results[0].source == "exploitdb"
        assert results[0].metadata["edb_id"] == "17491"
        assert results[0].metadata["title"] == "vsftpd 2.3.4 - Backdoor Command Execution"

    def test_parse_results_empty(self):
        """Test parsing empty results."""
        source = ExploitDbSource()
        json_output = json.dumps({"RESULTS_EXPLOIT": []})
        results = source._parse_results(json_output)
        assert results == []

    def test_parse_results_malformed(self):
        """Test parsing malformed JSON."""
        source = ExploitDbSource()
        results = source._parse_results("{invalid json")
        assert results == []

    def test_cve_extraction_integrated(self):
        """Test extraction of CVEs from title via parsing flow."""
        source = ExploitDbSource()
        json_output = json.dumps({
            "RESULTS_EXPLOIT": [
                {
                    "Title": "Apache Struts 2 - CVE-2017-5638 RCE",
                    "EDB-ID": "41570",
                    "Type": "webapps", 
                    "Platform": "linux",
                    "Path": "/path/41570.py",
                    "Codes": "CVE-2017-5638"
                }
            ]
        })
        
        results = source._parse_results(json_output)
        assert len(results) == 1
        assert "CVE-2017-5638" in results[0].metadata["cve_ids"]
        assert results[0].cve_id == "CVE-2017-5638"

    @pytest.mark.asyncio
    async def test_health_check_success(self):
        """Test health_check returns True when searchsploit is available."""
        source = ExploitDbSource()
        
        with patch("asyncio.base_events.BaseEventLoop.run_in_executor") as mock_run:
            mock_process = MagicMock()
            mock_process.returncode = 0
            mock_run.return_value = asyncio.Future()
            mock_run.return_value.set_result(mock_process)
            
            assert await source.health_check() is True

    @pytest.mark.asyncio
    async def test_health_check_failure(self):
        """Test health_check returns False when searchsploit fails."""
        source = ExploitDbSource()
        
        with patch("asyncio.base_events.BaseEventLoop.run_in_executor") as mock_run:
            # Simulate non-zero exit code
            mock_process = MagicMock()
            mock_process.returncode = 1
            mock_run.return_value = asyncio.Future()
            mock_run.return_value.set_result(mock_process)
            
            assert await source.health_check() is False
            
            # Simulate exception
            mock_run.side_effect = Exception("Error")
            assert await source.health_check() is False

    @pytest.mark.asyncio
    async def test_query_generic_exception(self):
        """Test that generic exceptions return empty list (covers L148-150)."""
        source = ExploitDbSource()
        
        with patch("asyncio.base_events.BaseEventLoop.run_in_executor") as mock_run:
            # Simulate an unexpected exception (not FileNotFoundError or TimeoutExpired)
            mock_run.side_effect = RuntimeError("Unexpected error")
            
            results = await source.query("test", "1.0")
            assert results == []

    def test_to_intel_result_relative_path(self):
        """Test path normalization for relative paths (covers L198)."""
        source = ExploitDbSource(base_path="/usr/share/exploitdb")
        
        # Entry with relative path (no leading /)
        entry = ExploitEntry(
            edb_id="12345",
            title="Test Exploit",
            path="exploits/unix/remote/12345.rb",  # Relative path
            platform="linux",
            exploit_type="remote",
        )
        
        result = source._to_intel_result(entry)
        
        # Path should be prefixed with base_path
        assert result.exploit_path == "/usr/share/exploitdb/exploits/unix/remote/12345.rb"
