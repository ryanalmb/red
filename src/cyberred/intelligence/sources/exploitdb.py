from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional

@dataclass
class ExploitEntry:
    """Normalized ExploitDB entry.
    
    Maps searchsploit JSON output to flat structure for IntelResult conversion.
    
    Attributes:
        edb_id: Exploit-DB ID (e.g., "17491")
        title: Exploit title (e.g., "vsftpd 2.3.4 - Backdoor Command Execution")
        path: Local path to exploit code (e.g., "/usr/share/exploitdb/exploits/unix/remote/17491.rb")
        platform: Target platform (e.g., "linux", "windows", "unix")
        exploit_type: Exploit type (e.g., "remote", "local", "webapps", "dos")
        author: Exploit author (optional)
        date: Publication date (optional, format "YYYY-MM-DD")
        cve_ids: List of associated CVE IDs (extracted from title or EDB data)
    """
    edb_id: str
    title: str
    path: str
    platform: str
    exploit_type: str
    author: str = ""
    date: str = ""
    cve_ids: List[str] = field(default_factory=list)

    @classmethod
    def from_searchsploit(cls, data: Dict[str, Any]) -> "ExploitEntry":
        """Create ExploitEntry from searchsploit JSON dictionary.
        
        Args:
            data: Dictionary from searchsploit --json output.
            
        Returns:
            ExploitEntry object.
        """
        # Extract CVEs from Codes field if available
        cve_ids = []
        codes = data.get("Codes", "")
        if codes:
            # Codes format: "OSVDB-73573;CVE-2011-2523"
            for code in codes.split(";"):
                if code.upper().startswith("CVE-"):
                    cve_ids.append(code.strip())
        
        # Also could extract from title if needed, but 'Codes' is more reliable if present
        # The prompt mentioned extracting from title, so let's check if we need that fallback
        # or if Codes is sufficient based on searchsploit output.
        # The example JSON showed "Codes": "OSVDB-73573;CVE-2011-2523"
        
        return cls(
            edb_id=data.get("EDB-ID", ""),
            title=data.get("Title", ""),
            path=data.get("Path", ""),
            platform=data.get("Platform", "unknown"),
            exploit_type=data.get("Type", "unknown"),
            author=data.get("Author", ""),
            date=data.get("Date_Published", ""),
            cve_ids=cve_ids
        )

from cyberred.intelligence.base import IntelligenceSource, IntelPriority, IntelResult
import asyncio
import subprocess
import json
import structlog

log = structlog.get_logger()

class ExploitDbSource(IntelligenceSource):
    """ExploitDB intelligence source using searchsploit CLI.
    
    Wraps the searchsploit command-line tool to query the local
    ExploitDB database for available exploits.
    
    Requires:
        - searchsploit installed (bundled with Kali)
        - exploitdb database present at /usr/share/exploitdb/
    
    Configuration:
        - No authentication required (local database)
        - No rate limiting (local queries)
    """
    
    def __init__(
        self,
        searchsploit_path: str = "searchsploit",
        timeout: float = 5.0,
        base_path: str = "/usr/share/exploitdb",
    ) -> None:
        super().__init__(
            name="exploitdb",
            timeout=timeout,
            priority=IntelPriority.EXPLOITDB,
        )
        self._searchsploit_path = searchsploit_path
        self._base_path = base_path

    async def query(self, service: str, version: str) -> List[IntelResult]:
        """Query ExploitDB for exploits affecting service/version.
        
        Uses searchsploit CLI with --json flag for structured output.
        
        Args:
            service: Service name (e.g., "vsftpd", "Apache")
            version: Version string (e.g., "2.3.4", "2.4.49")
            
        Returns:
            List of IntelResult sorted by relevance.
            Empty list on any error.
        """
        log.info("exploitdb_query_start", service=service, version=version)
        
        try:
            # Sanitize inputs to prevent shell injection or search errors
            safe_service = "".join(c for c in service if c.isalnum() or c in " .-_")
            safe_version = "".join(c for c in version if c.isalnum() or c in " .-_")
            query_str = f"{safe_service} {safe_version}".strip()
            
            # Build searchsploit command
            cmd = [self._searchsploit_path, "--json", query_str]
            
            # Run searchsploit asynchronously
            loop = asyncio.get_event_loop()
            result = await asyncio.wait_for(
                loop.run_in_executor(
                    None,
                    lambda: subprocess.run(
                        cmd,
                        capture_output=True,
                        text=True,
                        timeout=self._timeout,
                    )
                ),
                timeout=self._timeout + 1,  # Extra second for executor overhead
            )
            
            if result.returncode != 0:
                log.warning("exploitdb_query_failed", stderr=result.stderr)
                return []
            
            return self._parse_results(result.stdout)
        except (FileNotFoundError, subprocess.TimeoutExpired) as e:
            log.warning("exploitdb_query_error", error=str(e))
            return []
        except Exception as e:
            log.warning("exploitdb_query_failed", error=str(e))
            return []

    def _parse_results(self, json_output: str) -> List[IntelResult]:
        """Parse searchsploit JSON output to IntelResults.
        
        Args:
            json_output: Raw JSON string from searchsploit.
            
        Returns:
            List of IntelResult objects.
        """
        try:
            data = json.loads(json_output)
        except json.JSONDecodeError:
            log.warning("exploitdb_json_parse_failed")
            return []
        
        results = []
        exploits = data.get("RESULTS_EXPLOIT", [])
        
        for entry_data in exploits:
            entry = ExploitEntry.from_searchsploit(entry_data)
            # Normalize platform to lowercase
            entry.platform = entry.platform.lower() if entry.platform else "unknown"
            result = self._to_intel_result(entry)
            results.append(result)
        
        log.info("exploitdb_query_complete", result_count=len(results))
        return results

    def _to_intel_result(self, entry: ExploitEntry) -> IntelResult:
        """Convert ExploitDB entry to IntelResult.
        
        Args:
            entry: Normalized ExploitDB entry.
            
        Returns:
            IntelResult with ExploitDB-specific metadata.
        """
        # Determine CVE ID (first from list, or None)
        cve_id = entry.cve_ids[0] if entry.cve_ids else None
        
        # Infer severity from exploit type
        severity = self._type_to_severity(entry.exploit_type)
        
        # Ensure exploit path is absolute
        exploit_path = entry.path
        if exploit_path and not exploit_path.startswith("/"):
            exploit_path = f"{self._base_path}/{exploit_path}"
        
        return IntelResult(
            source="exploitdb",
            cve_id=cve_id,
            severity=severity,
            exploit_available=True,  # ExploitDB = exploit exists
            exploit_path=exploit_path,
            confidence=0.8,  # Base confidence for keyword match
            priority=IntelPriority.EXPLOITDB,
            metadata={
                "edb_id": entry.edb_id,
                "title": entry.title,
                "platform": entry.platform,
                "exploit_type": entry.exploit_type,
                "author": entry.author,
                "date": entry.date,
                "cve_ids": entry.cve_ids,
            },
        )

    def _type_to_severity(self, exploit_type: str) -> str:
        """Map exploit type to severity string.
        
        Remote and webapps exploits are considered higher severity
        as they typically allow remote code execution.
        
        Args:
            exploit_type: ExploitDB type (remote, local, webapps, dos, etc.)
            
        Returns:
            Severity string: "critical", "high", "medium", "low", or "info".
        """
        severity_map = {
            "remote": "high",
            "webapps": "high",
            "local": "medium",
            "dos": "medium",
            "shellcode": "high",
        }
        return severity_map.get(exploit_type.lower(), "medium")

    async def health_check(self) -> bool:
        """Check if searchsploit is available.
        
        Runs `searchsploit --help` to verify the binary exists
        and is executable.
        
        Returns:
            True if searchsploit is available, False otherwise.
        """
        try:
            loop = asyncio.get_event_loop()
            result = await asyncio.wait_for(
                loop.run_in_executor(
                    None,
                    lambda: subprocess.run(
                        [self._searchsploit_path, "--help"],
                        capture_output=True,
                        timeout=3,
                    )
                ),
                timeout=5.0,
            )
            # searchsploit --help may return 0 or 2 depending on version/environment
            return result.returncode in [0, 2]
        except Exception:
            return False
