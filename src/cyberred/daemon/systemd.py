"""systemd Integration for Cyber-Red Daemon.

Provides functions to generate and install a systemd service file
for running the Cyber-Red daemon as a managed system service.

Usage:
    from cyberred.daemon.systemd import generate_service_file, write_service_file

    # Generate service file content
    content = generate_service_file(user="cyberred")

    # Write to system location (requires root)
    write_service_file(content)
"""

from __future__ import annotations

import os
import shutil
import subprocess
import sys
import tempfile
from pathlib import Path
from typing import Optional

import structlog

log = structlog.get_logger()


# Default service file path
DEFAULT_SERVICE_PATH = Path("/etc/systemd/system/cyber-red.service")


# Service file template per architecture document
SERVICE_TEMPLATE = """\
# /etc/systemd/system/cyber-red.service
# Cyber-Red Daemon Service File
# Generated by: cyber-red daemon install

[Unit]
Description=Cyber-Red Daemon
After=network.target redis.service

[Service]
Type=simple
ExecStart={exec_path} daemon start --foreground
ExecStop={exec_path} daemon stop
Restart=on-failure
RestartSec=5
User={user}
Environment="PYTHONUNBUFFERED=1"
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
"""


def _get_default_exec_path() -> Path:
    """Get the default executable path for cyber-red.

    Attempts to find the cyber-red executable in the following order:
    1. `cyber-red` in PATH
    2. Python executable with -m cyberred.cli
    3. /usr/local/bin/cyber-red as fallback

    Returns:
        Path to cyber-red executable.
    """
    # Try to find cyber-red in PATH
    cyber_red_path = shutil.which("cyber-red")
    if cyber_red_path:
        return Path(cyber_red_path)

    # Fallback to standard installation path
    return Path("/usr/local/bin/cyber-red")


def generate_service_file(
    user: str = "cyberred",
    exec_path: Optional[Path] = None,
) -> str:
    """Generate systemd service file content.

    Args:
        user: Username to run the service as. Default: "cyberred".
        exec_path: Path to cyber-red executable. Auto-detected if not provided.

    Returns:
        Service file content as a string.
    """
    if exec_path is None:
        exec_path = _get_default_exec_path()

    # Validate username to prevent injection
    # Allow alphanumeric, dashes, and underscores only
    import re
    if not re.match(r"^[a-z_][a-z0-9_-]*$", user):
        raise ValueError(f"Invalid username '{user}': must match checked regular expression")

    return SERVICE_TEMPLATE.format(
        exec_path=str(exec_path),
        user=user,
    )


def write_service_file(
    content: str,
    service_path: Path = DEFAULT_SERVICE_PATH,
) -> None:
    """Write service file to system location atomically.

    Writes to a temporary file first, then renames to avoid partial writes.
    Sets permissions to 644 (rw-r--r--).

    Args:
        content: Service file content to write.
        service_path: Path to write service file. Default: /etc/systemd/system/cyber-red.service

    Raises:
        PermissionError: If not running as root.
        OSError: If file operations fail.
    """
    if os.geteuid() != 0:
        raise PermissionError("Writing service file requires root privileges")

    # Ensure parent directory exists
    service_path.parent.mkdir(parents=True, exist_ok=True)

    # Write atomically: temp file then rename
    fd, temp_path = tempfile.mkstemp(
        suffix=".service",
        dir=service_path.parent,
    )
    try:
        with os.fdopen(fd, "w") as f:
            f.write(content)

        # Set permissions: 644 (rw-r--r--)
        os.chmod(temp_path, 0o644)

        # Atomic rename
        os.rename(temp_path, service_path)

        log.info("service_file_written", path=str(service_path))

    except Exception:
        # Clean up temp file on error
        if os.path.exists(temp_path):
            os.unlink(temp_path)
        raise


def create_service_user(username: str = "cyberred") -> bool:
    """Create a system user for running the Cyber-Red daemon.

    Creates a system user with no login shell and a home directory
    at /var/lib/cyber-red.

    Args:
        username: Username to create. Default: "cyberred".

    Returns:
        True if user was created, False if user already exists.

    Raises:
        PermissionError: If not running as root.
        subprocess.CalledProcessError: If useradd fails.
    """
    if os.geteuid() != 0:
        raise PermissionError("Creating service user requires root privileges")

    # Check if user already exists
    result = subprocess.run(
        ["id", username],
        capture_output=True,
    )
    if result.returncode == 0:
        log.info("service_user_exists", username=username)
        return False

    # Create system user
    home_dir = Path("/var/lib/cyber-red")
    subprocess.run(
        [
            "useradd",
            "--system",
            "--shell", "/sbin/nologin",
            "--home-dir", str(home_dir),
            "--create-home",
            username,
        ],
        check=True,
    )

    log.info("service_user_created", username=username, home_dir=str(home_dir))
    return True


def ensure_storage_directory(
    base_path: Path,
    username: str = "cyberred",
) -> None:
    """Ensure storage directory exists with correct ownership.

    Creates the storage directory if it doesn't exist and sets
    ownership to the specified user.

    Args:
        base_path: Path to storage directory (e.g., ~/.cyber-red/).
        username: Username to set as owner.

    Raises:
        PermissionError: If not running as root.
        subprocess.CalledProcessError: If chown fails.
    """
    if os.geteuid() != 0:
        raise PermissionError("Setting directory ownership requires root privileges")

    # Create directory
    base_path.mkdir(parents=True, exist_ok=True)

    # Set ownership
    subprocess.run(
        ["chown", "-R", f"{username}:{username}", str(base_path)],
        check=True,
    )

    log.info("storage_directory_configured", path=str(base_path), owner=username)


def reload_systemd() -> None:
    """Reload systemd manager configuration.

    Runs `systemctl daemon-reload` to reload unit files.

    Raises:
        PermissionError: If not running as root.
        subprocess.CalledProcessError: If systemctl fails.
    """
    if os.geteuid() != 0:
        raise PermissionError("Reloading systemd requires root privileges")

    subprocess.run(["systemctl", "daemon-reload"], check=True)
    log.info("systemd_reloaded")


def enable_service(service_name: str = "cyber-red") -> None:
    """Enable a systemd service to start on boot.

    Runs `systemctl enable <service>`.

    Args:
        service_name: Name of the service to enable.

    Raises:
        PermissionError: If not running as root.
        subprocess.CalledProcessError: If systemctl fails.
    """
    if os.geteuid() != 0:
        raise PermissionError("Enabling service requires root privileges")

    subprocess.run(["systemctl", "enable", service_name], check=True)
    log.info("service_enabled", service=service_name)


def disable_service(service_name: str = "cyber-red") -> None:
    """Disable a systemd service from starting on boot.

    Runs `systemctl disable <service>`.

    Args:
        service_name: Name of the service to disable.

    Raises:
        subprocess.CalledProcessError: If systemctl fails.
    """
    subprocess.run(["systemctl", "disable", service_name], check=True)
    log.info("service_disabled", service=service_name)


def stop_service(service_name: str = "cyber-red") -> None:
    """Stop a systemd service.

    Runs `systemctl stop <service>`. Does not fail if service is not running.

    Args:
        service_name: Name of the service to stop.
    """
    result = subprocess.run(
        ["systemctl", "stop", service_name],
        capture_output=True,
    )
    if result.returncode == 0:
        log.info("service_stopped", service=service_name)
    else:
        # Service might not be running, that's OK
        log.debug("service_stop_result", service=service_name, returncode=result.returncode)


def remove_service_file(service_path: Path = DEFAULT_SERVICE_PATH) -> None:
    """Remove the service file.

    Args:
        service_path: Path to service file to remove.

    Raises:
        FileNotFoundError: If service file doesn't exist.
    """
    if not service_path.exists():
        raise FileNotFoundError(f"Service file not found: {service_path}")

    service_path.unlink()
    log.info("service_file_removed", path=str(service_path))
